    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Text;

namespace GhostscriptSharp.API
{
    public static class GhostScript
    {
        /// <summary>
        /// Calls the Ghostscript API with a collection of arguments to be passed to it
        /// </summary>
        public static void CallAPI(string[] args)
        {
            // Get a pointer to an instance of the Ghostscript API and run the API with the current arguments
            IntPtr gsInstancePtr;
            lock (resourceLock)
            {
                if (Environment.Is64BitProcess)
                {
                    NativeFunctions.CreateAPIInstance64(out gsInstancePtr, IntPtr.Zero);
                try
                {
                    int result = NativeFunctions.InitAPI64(gsInstancePtr, args.Length, args);

                    if (result < 0)
                    {
                        throw new ExternalException("Ghostscript conversion error", result);
                    }
                }
                finally
                {
                    Cleanup(gsInstancePtr);
                }
                }
                else
                {
                    NativeFunctions.CreateAPIInstance32(out gsInstancePtr, IntPtr.Zero);
                try
                {
                    int result = NativeFunctions.InitAPI32(gsInstancePtr, args.Length, args);

                    if (result < 0)
                    {
                        throw new ExternalException("Ghostscript conversion error", result);
                    }
                }
                finally
                {
                    Cleanup(gsInstancePtr);
                }
                }

            }
        }

        /// <summary>
        /// Frees up the memory used for the API arguments and clears the Ghostscript API instance
        /// </summary>
        private static void Cleanup(IntPtr gsInstancePtr)
        {
            if (Environment.Is64BitProcess)
            {
                NativeFunctions.ExitAPI64(gsInstancePtr);
                NativeFunctions.DeleteAPIInstance64(gsInstancePtr);
            }
            else
            {
                NativeFunctions.ExitAPI32(gsInstancePtr);
                NativeFunctions.DeleteAPIInstance32(gsInstancePtr);
            }
        }

        /// <summary>
        /// GS can only support a single instance, so we need to bottleneck any multi-threaded systems.
        /// </summary>
        private static object resourceLock = new object();

        #region Handle stdio

        /// <summary>
        /// Callback used by Ghostscript API when reading from stdin
        /// </summary>
        /// <param name="caller_handle">The caller_handle supplied to CreateAPIInstance</param>
        /// <param name="buf">The value to provide to Ghostscript from stdin</param>
        /// <param name="len">The number of characters provided</param>
        /// <returns>0 for EOF, or -1 for error, number of characters provided for success</returns>
        public delegate Int32 StdinCallback(IntPtr caller_handle, IntPtr buf, Int32 len);

        /// <summary>
        /// Callback used by Ghostscript API when writing to stdout or stderr
        /// </summary>
        /// <param name="caller_handle">The caller_handle supplied to CreateAPIInstance</param>
        /// <param name="buf">The string output generated by Ghostscript. Note that the buf may be longer than the provided output, use buf.ToString(0, len)</param>
        /// <param name="len">The length of the generated output</param>
        /// <returns></returns>
        public delegate Int32 StdoutCallback(IntPtr caller_handle, String buf, Int32 len);

        #endregion
    }
}